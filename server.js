/**
 * File: server.js
 * Author: Stef Timmermans
 * Date: 10 November 2023
 * Description:
 *   This is the entry point for the application. It holds
 *   the routes for the users, the boats, and the loads.
 *   It involves making JWTs through Auth0, and using
 *   Google Cloud Datastore to store the data. It is hosted
 *   on Gloogle Cloud App Engine.
 * 
 *   Some of this file's contents are based on existing
 *   code from the Oregon State University's CS 493 ecampus
 *   course.
 */

const express = require('express');                         // Express for web framework
const app = express();                                      // Create an Express app
const { Datastore } = require('@google-cloud/datastore');   // Google Cloud Datastore for noSQL database
const bodyParser = require('body-parser');                  // Body parser for parsing JSON
require('dotenv').config();                                 // Dotenv for environment variables
const jwt = require('express-jwt');                         // JWT for authentication
const jwksRsa = require('jwks-rsa');                        // JWKS for authentication
const { Datastore } = require('@google-cloud/datastore');

// Use EJS for templating
app.set('view engine', 'ejs');                              // Set EJS as templating engine
app.set('views', __dirname + '/views');                     // Set views directory

// Use express-openid-connect for authentication
// const { auth, requiresAuth } = require('express-openid-connect');

// Use body parser for parsing JSON
app.use(bodyParser.json());

// Keyile for local development
// const keyfile = './keyfile.json';

// Datastore for local development
// const datastore = new Datastore({ keyFilename: keyfile });

// Datastore for Google Cloud App Engine
//const datastore = new Datastore();

// Constants for the datastore
const USER = "User";
const BOAT = "Boat";
const LOAD = "Load";

// Secrets for JWT using the .env file
// const CLIENT_ID = process.env.CLIENT_ID;
// const CLIENT_SECRET = process.env.CLIENT_SECRET;
// const DOMAIN = process.env.DOMAIN;

// Configure express-openid-connect

/*
Boat
{ "id": 1234,      # automatically generated by Datastore
  "name": "Sea Witch",  # The name of the boat, a string
  "type": "Catamaran",   # The type of boat, power boat, sailboat, catamaran etc. a string
  "length": 28,          # The length of the boat, an integer
  "loads":[
   {"id": 5678,
    "self":"https://appspot.com/loads/5678"},
    {"id": 8765,
    "self":"https://appspot.com/loads/8765"}
  ], # This embedded list does NOT need to paginate.
 "self":"https://appspot.com/boats/1234"
}
Load
{ "id": 5678, # automatically generated by the Datastore
  "volume": 5,     # The volume of the load, an integer
  "carrier": {
    "id": 1234,
    "name": "Sea Witch",
    "self": "https://appspot.com/boats/1234"
  },  # The boat carrying the load
  "item": "LEGO Blocks",
  "creation_date": "10/18/2020" # Date the load was created
  "self":"https://appspot.com/loads/5678"
}
*/

/* ---- Begin Helper Functions ---- */

/**
 * Function: fromDatastore
 * Parameters: req, item, type
 * Returns: item
 * Description:
 *   This function takes in a datastore item and returns
 *   it with the appropriate ID and self link. This is
 *   used for all datastore items except users, which
 *   only have an ID.
 */
function fromDatastore(req, item, type) {
    item.id = item[datastore.KEY].id;
    if (item.id != null) {
        item.self = getSelfLink(req, type, item.id);
    }
    return item;
}

/**
 * Function: userFromDatastore
 * Parameters: req, item, type
 * Returns: item
 * Description:
 *   This function takes in a datastore item and returns
 *   it with the appropriate ID. This is used for users,
 *   which only have an ID.
 */
function userFromDatastore(item) {
    item.id = item[datastore.KEY].id;
    return item;
}

/**
 * Function: getSelfLink
 * Parameters: req, type, id
 * Returns: String
 * Description:
 *   This function takes in a request, a type, and an ID
 *   and returns the self link for that item. This is
 *   assembled by obtaining the host from the request
 *   and appending the relative path to the item (this
 *   creates the true URL for the item).
 */
function getSelfLink(req, type, id) {
    // Grabs the host and assembles the self link
    return `https://${req.get('host')}/${type}/${id}`;s
}

/**
 * Function: getTotalBoatCount
 * Parameters: None
 * Returns: Integer
 * Description:
 *   This function returns the total number of boats
 *   in the datastore. It is used for collection
 *   responses.
 */
function getTotalBoatCount() {
    const keyQuery = datastore.createQuery(BOAT).select('__key__');
    return datastore.runQuery(keyQuery).then(results => results[0].length);
}

/**
 * Function: getTotalLoadCount
 * Parameters: None
 * Returns: Integer
 * Description:
 *   This function returns the total number of loads
 *   in the datastore. It is used for collection
 *   responses.
 */
function getTotalLoadCount() {
    const keyQuery = datastore.createQuery(LOAD).select('__key__');
    return datastore.runQuery(keyQuery).then(results => results[0].length);
}

/* ---- End Helper Functions ---- */

/* ---- Begin User Model Functions ---- */

/**
 * Function: post_user
 * Parameters: N/A
 * Returns: Key of new user
 * Description:
 *   This function creates a new user in the datastore.
 *   A user's only property is their ID, which is
 *   automatically generated by the datastore.
 */
function post_user() {
    // Create a new user entity
    const key = datastore.key(USER);
    const new_user = {};

    // Save the new user entity and return the key
    return datastore.save({ "key": key, "data": new_user })
    .then(() => {
        return key;
    });
}

/**
 * Function: get_users
 * Parameters: None
 * Returns: JSON
 * Description:
 *   This function returns all users in the datastore,
 *   displaying their IDs. This is the only collection
 *   that does not need to be paginated.
 */
function get_users() {
    // Create a query for all users
    const query = datastore.createQuery(USER);

    // Return all users in the datastore
    return datastore.runQuery(query)
    .then((entities) => {
        return entities[0].map(userFromDatastore);
    });
}

/* ---- End User Model Functions ---- */

// REMEMBER TO ADD SUB PROPERTY TO BOAT AND LOAD

/* ---- Begin Boat Model Functions ---- */

/**
 * Function: post_boat
 * Parameters: name, type, length
 * Returns: Key of new boat
 * Description:
 *   This function creates a new boat in the datastore. It
 *   takes in the appropriate authentication information
 *   (TODO) and the boat's name, type, and length. It then
 *   creates a new boat entity in the datastore with these
 *   properties and an empty list of loads.
 */
function post_boat(name, type, length) {
    // Create a new boat entity
    const key = datastore.key(BOAT);
    const new_boat = {
        "name": name,
        "type": type,
        "length": length,
        "loads": []
    };

    // Save the new boat entity and return the key
    return datastore.save({ "key": key, "data": new_boat })
    .then(() => {
        return key;
    });
}

/**
 * Function: get_all_boats
 * Parameters: Cursor (optional)
 * Returns: JSON
 * Description:
 *   This function returns all boats in the datastore,
 *   displaying their IDs, names, types, lengths, loads,
 *   and self links. It should also include a 'count' of
 *   the total number of boats in the datastore. Finally,
 *   this request is paginated, so it should include up to
 *   five boats per page, with a 'next' link if there are
 *   more boats to display. The first boat is either at the
 *   first index of the datastore or at the index specified
 *   by the 'cursor' query parameter.
 */
async function get_all_boats(req) {
    // Limit the query to 5 boats
    const boatsQuery = datastore.createQuery(BOAT).limit(5);

    // Handling pagination with cursor
    if (req.query.cursor) {
        boatsQuery.start(req.query.cursor);
    }

    // Run query to get boats with pagination
    // Await the result
    const boatsResult = await datastore.runQuery(boatsQuery);

    // Boats holds the boats, info holds the pagination info
    const boats = boatsResult[0];
    const info = boatsResult[1];

    // Format the boats with ids and self links
    const formattedBoats = boats.map(boat => fromDatastore(req, boat, 'boats'));

    // Get total count of boats
    const totalBoatsCount = await getTotalBoatCount();

    // Prepare the response
    const response = {
        boats: formattedBoats,
        count: totalBoatsCount
    };

    // Add a 'next' link if there are more boats to display
    if (info.moreResults !== Datastore.NO_MORE_RESULTS) {
        // HTTP for localhost, HTTPS for App Engine
        response.next = `http://${req.get('host')}/boats?cursor=${info.endCursor}`;
    }

    // Return the fully assembled response in format:
    // { boats: [boat1, boat2, ...], count: 5, next: '???' or not included }
    return response;
}

/**
 * Function: get_boats_by_owner
 * IMPLEMENTATION TBD
 */

/* ---- End Boat Model Functions ---- */

/* ---- Begin Load Model Functions ---- */

/**
 * Function: post_load
 * Parameters: volume, item
 * Returns: Key of new load
 * Description:
 *   This function creates a new load in the datastore. It
 *   takes in the appropriate authentication information
 *   (TODO) and the load's volume and item. It then creates
 *   a new load entity in the datastore with these properties,
 *   an empty carrier, and the current date.
 */
function post_load(volume, item) {
    // Get the current date, using US format
    // Enforce "MM/DD/YYYY" incase something weird happens with the testing suite
    const CURRENT_DATE = new Date().toLocaleDateString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
    });

    // Create a new load entity
    const key = datastore.key(LOAD);
    const new_load = {
        "volume": volume,
        "carrier": {},
        "item": item,
        "creation_date": CURRENT_DATE
    };

    // Save the new load entity and return the key
    return datastore.save({ "key": key, "data": new_load })
    .then(() => {
        return key;
    });
}

/* ---- End Load Model Functions ---- */

/* ---- Begin Boat/Load Model Functions ---- */

/* ---- End Boat/Load Model Functions ---- */

/* ---- Begin User Routes ---- */

/**
 * Debug Route: POST /users
 * IMPLEMENTATION TBD
 */

/**
 * Route: GET /users
 * Parameters: None
 * Description:
 *   This route returns all users in the datastore,
 *   displaying their IDs. This is the only collection
 *   that does not need to be paginated.
 * Status Codes:
 *   200 - Users returned successfully.
 */
app.get('/users', (req, res) => {
    // Return all users in the datastore
    get_users()
    .then((users) => {
        res.status(200).json(users);
    })
    .catch((err) => {
        res.status(500).json({ Error: err });
    });
});

/* ---- End User Routes ---- */

/* ---- Begin Boat Routes ---- */

/**
 * Route: POST /boats
 * Parameters: name, type, length (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   This route creates a new boat in the datastore with
 *   the given parameters and an empty list of loads. The
 *   request must include a valid JWT in the Authorization
 *   header.
 * Status Codes:
 *   201 - Boat created successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: GET /boats/:boat_id
 * Parameters: boat_id (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   This route returns the boat with the given ID. This
 *   route is not protected.
 * Status Codes:
 *   200 - Boat returned successfully.
 *   404 - Boat not found.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: GET /boats
 * Parameters: N/A
 * Returns: List of boats (via JSON)
 * Description:
 *   This route returns all boats in the datastore.
 *   If a valid JWT is provided, then only the boats
 *   owned by the user are returned. Otherwise, all
 *   boats are returned. The response is paginated
 *   with a maximum of five boats per page.
 * Status Codes:
 *   200 - Boats returned successfully.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: PUT /boats/:boat_id
 * Parameters: boat_id, name, type, length (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   Replace the boat with the given ID with the given
 *   parameters. The request must include all parameters
 *   or it is invalid. The request must also include a
 *   valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Boat replaced successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat not found.
 *   405 - Boat has a load(s) and cannot be replaced.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: PATCH /boats/:boat_id
 * Parameters: boat_id, name, type, length (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   Update the boat with the given ID with the given
 *   parameters. The request must include at least one
 *   parameter or it is invalid. The request must also
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Boat updated successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat not found.
 *   405 - Boat has a load(s) and cannot be updated.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: DELETE /boats/:boat_id
 * Parameters: boat_id (via JSON)
 * Returns: N/A
 * Description:
 *   Delete the boat with the given ID. The request must
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   204 - Boat deleted successfully.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat not found.
 *   405 - Boat has a load(s) and cannot be deleted.
 */

/* ---- End Boat Routes ---- */

/* ---- Begin Load Routes ---- */

/**
 * Route: POST /loads
 * Parameters: volume, item (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *   This route creates a new load in the datastore with
 *   the given parameters, an empty carrier, and the
 *   current date. The request must include a valid JWT
 *   in the Authorization header.
 * Status Codes:
 *   201 - Load created successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: GET /loads/:load_id
 * Parameters: load_id (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *  This route returns the load with the given ID. This
 *  route is not protected.
 * Status Codes:
 *   200 - Load returned successfully.
 *   404 - Load not found.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: GET /loads
 * Parameters: N/A
 * Returns: List of loads (via JSON)
 * Description:
 *   This route returns all loads in the datastore.
 *   If a valid JWT is provided, then only the loads
 *   carried by the user's boats are returned. Otherwise,
 *   all loads are returned. The response is paginated
 *   with a maximum of five loads per page.
 * Status Codes:
 *   200 - Loads returned successfully.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: PUT /loads/:load_id
 * Parameters: load_id, volume, item (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *   Replace the load with the given ID with the given
 *   parameters. The request must include all parameters
 *   or it is invalid. The request must also include a
 *   valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Load replaced successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Load not found.
 *   405 - Load is assigned to a boat and cannot be replaced.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: PATCH /loads/:load_id
 * Parameters: load_id, volume, item (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *   Update the load with the given ID with the given
 *   parameters. The request must include at least one
 *   parameter or it is invalid. The request must also
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Load updated successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Load not found.
 *   405 - Load is assigned to a boat and cannot be updated.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: DELETE /loads/:load_id
 * Parameters: load_id (via JSON)
 * Returns: N/A
 * Description:
 *   Delete the load with the given ID. The request must
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   204 - Load deleted successfully.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Load not found.
 *   405 - Load is assigned to a boat and cannot be deleted.
 */

/* ---- End Load Routes ---- */

/* ---- Begin Boat/Load Routes ---- */

/**
 * Route: PATCH /boats/:boat_id/loads/:load_id
 * Parameters: boat_id, load_id (via JSON)
 * Returns: Updated Boat object with appended Load information (via JSON)
 * Description:
 *   This route appends the specified load to the specified boat's
 *   list of loads.  The load must not already be assigned to any
 *   boat.  The request must include a valid JWT in the Authorization
 *   header.
 * Status Codes:
 *   200 - Load appended to boat successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat or Load not found.
 *   405 - Load is already assigned to a boat.
 *   406 - Client does not accept JSON.
 */

/**
 * Route: DELETE /boats/:boat_id/loads/:load_id
 * Parameters: boat_id, load_id (via JSON)
 * Returns: Updated Boat object with removed Load information (via JSON)
 * Description:
 *   This route removes the specified load from the specified boat's
 *   list of loads.  The load must already be assigned to the boat.
 *   The request must include a valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Load removed from boat successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat or Load not found.
 *   405 - Load is not assigned to the boat.
 *   406 - Client does not accept JSON.
 */

/* ---- End Boat/Load Routes ---- */

// Listen to the App Engine-specified port, or 8080 otherwise
const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}...`);
});
