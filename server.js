/**
 * File: server.js
 * Author: Stef Timmermans
 * Date: 10 November 2023
 * Description:
 *   This is the entry point for the application. It holds
 *   the routes for the users, the boats, and the loads.
 *   It involves making JWTs through Auth0, and using
 *   Google Cloud Datastore to store the data. It is hosted
 *   on Gloogle Cloud App Engine.
 * 
 *   Some of this file's contents are based on existing
 *   code from the Oregon State University's CS 493 ecampus
 *   course.
 */

const express = require('express');                         // Express for web framework
const app = express();                                      // Create an Express app
const { Datastore } = require('@google-cloud/datastore');   // Google Cloud Datastore for noSQL database
const bodyParser = require('body-parser');                  // Body parser for parsing JSON
require('dotenv').config();                                 // Dotenv for environment variables
const jwt = require('express-jwt');                         // JWT for authentication
const jwksRsa = require('jwks-rsa');                        // JWKS for authentication
const { Datastore } = require('@google-cloud/datastore');

// Use EJS for templating
app.set('view engine', 'ejs');                              // Set EJS as templating engine
app.set('views', __dirname + '/views');                     // Set views directory

// Use express-openid-connect for authentication
const { auth, requiresAuth } = require('express-openid-connect');

// Use body parser for parsing JSON
app.use(bodyParser.json());

// Keyile for local development
const keyfile = './keyfile.json';

// Datastore for local development
const datastore = new Datastore({ keyFilename: keyfile });

// Datastore for Google Cloud App Engine
//const datastore = new Datastore();

// Constants for the datastore
const USER = "User";
const BOAT = "Boat";
const LOAD = "Load";

// Secrets for JWT using the .env file
const CLIENT_ID = process.env.CLIENT_ID;
const CLIENT_SECRET = process.env.CLIENT_SECRET;
const DOMAIN = process.env.DOMAIN;

// Enforce JWT authentication
const checkJwt = jwt({
    secret: jwksRsa.expressJwtSecret({
      cache: true,
      rateLimit: true,
      jwksRequestsPerMinute: 5,
      jwksUri: `https://${DOMAIN}/.well-known/jwks.json`
    }),
  
    // Validate the audience and the issuer.
    issuer: `https://${DOMAIN}/`,
    algorithms: ['RS256']
});

// Check JWT but don't enforce it
const checkJwtOptional = jwt({
    secret: jwksRsa.expressJwtSecret({
        cache: true,
        rateLimit: true,
        jwksRequestsPerMinute: 5,
        jwksUri: `https://${DOMAIN}/.well-known/jwks.json`
    }),

    // Validate but bypass throwing error if JWT is invalid
    issuer: `https://${DOMAIN}/`,
    algorithms: ['RS256'],
    credentialsRequired: false
});

/*
Boat
{ "id": 1234,      # automatically generated by Datastore
  "name": "Sea Witch",  # The name of the boat, a string
  "type": "Catamaran",   # The type of boat, power boat, sailboat, catamaran etc. a string
  "length": 28,          # The length of the boat, an integer
  "loads":[
   {"id": 5678,
    "self":"https://appspot.com/loads/5678"},
    {"id": 8765,
    "self":"https://appspot.com/loads/8765"}
  ], # This embedded list does NOT need to paginate.
  "owner": "auth0|1234567890", # The owner of the boat, a string
  "self":"https://appspot.com/boats/1234"
}
Load
{ "id": 5678, # automatically generated by the Datastore
  "volume": 5,     # The volume of the load, an integer
  "carrier": {
    "id": 1234,
    "name": "Sea Witch",
    "self": "https://appspot.com/boats/1234"
  },  # The boat carrying the load
  "item": "LEGO Blocks",
  "creation_date": "10/18/2020" # Date the load was created
  "owner": "auth0|1234567890", # The owner of the load, a string
  "self":"https://appspot.com/loads/5678"
}
*/

/* ---- Begin Helper Functions ---- */

/**
 * Function: fromDatastore
 * Parameters: req, item, type
 * Returns: item
 * Description:
 *   This function takes in a datastore item and returns
 *   it with the appropriate ID and self link. This is
 *   used for all datastore items except users, which
 *   only have an ID.
 */
function fromDatastore(req, item, type) {
    item.id = item[datastore.KEY].id;
    if (item.id != null) {
        item.self = getSelfLink(req, type, item.id);
    }
    return item;
}

/**
 * Function: userFromDatastore
 * Parameters: req, item, type
 * Returns: item
 * Description:
 *   This function takes in a datastore item and returns
 *   it with the appropriate ID. This is used for users,
 *   which only have an ID.
 */
function userFromDatastore(item) {
    item.id = item[datastore.KEY].id;
    return item;
}

/**
 * Function: getSelfLink
 * Parameters: req, type, id
 * Returns: String
 * Description:
 *   This function takes in a request, a type, and an ID
 *   and returns the self link for that item. This is
 *   assembled by obtaining the host from the request
 *   and appending the relative path to the item (this
 *   creates the true URL for the item).
 */
function getSelfLink(req, type, id) {
    // Grabs the host and assembles the self link
    return `https://${req.get('host')}/${type}/${id}`;
}

/**
 * Function: getTotalBoatCount
 * Parameters: None
 * Returns: Integer
 * Description:
 *   This function returns the total number of boats
 *   in the datastore. It is used for collection
 *   responses.
 */
function getTotalBoatCount() {
    const keyQuery = datastore.createQuery(BOAT).select('__key__');
    return datastore.runQuery(keyQuery).then(results => results[0].length);
}

/**
 * Function: getTotalBoatCountByOwner
 * Parameters: owner
 * Returns: Integer
 * Description:
 *   This function returns the total number of boats
 *   owned by the user with the given owner ID. It is
 *   used for collection responses.
 */
function getTotalBoatCountByOwner(owner) {
    const keyQuery = datastore.createQuery(BOAT).filter('owner', '=', owner).select('__key__');
    return datastore.runQuery(keyQuery).then(results => results[0].length);
}

/**
 * Function: getTotalLoadCount
 * Parameters: None
 * Returns: Integer
 * Description:
 *   This function returns the total number of loads
 *   in the datastore. It is used for collection
 *   responses.
 */
function getTotalLoadCount() {
    const keyQuery = datastore.createQuery(LOAD).select('__key__');
    return datastore.runQuery(keyQuery).then(results => results[0].length);
}

/**
 * Function: getTotalLoadCountByOwner
 * Parameters: owner
 * Returns: Integer
 * Description:
 *   This function returns the total number of loads
 *   owned by the user with the given owner ID. It is
 *   used for collection responses.
 */
function getTotalLoadCountByOwner(owner) {
    const keyQuery = datastore.createQuery(LOAD).filter('owner', '=', owner).select('__key__');
    return datastore.runQuery(keyQuery).then(results => results[0].length);
}

/* ---- End Helper Functions ---- */

/* ---- Begin User Model Functions ---- */

/**
 * Function: post_user
 * Parameters: N/A
 * Returns: Key of new user
 * Description:
 *   This function creates a new user in the datastore.
 *   A user's only property is their ID, which is
 *   automatically generated by the datastore.
 */
function post_user() {
    // Create a new user entity
    const key = datastore.key(USER);
    const new_user = {};

    // Save the new user entity and return the key
    return datastore.save({ "key": key, "data": new_user })
    .then(() => {
        return key;
    });
}

/**
 * Function: get_users
 * Parameters: None
 * Returns: List of users
 * Description:
 *   This function returns all users in the datastore,
 *   displaying their IDs. This is the only collection
 *   that does not need to be paginated.
 */
function get_users() {
    // Create a query for all users
    const query = datastore.createQuery(USER);

    // Return all users in the datastore
    return datastore.runQuery(query)
    .then((entities) => {
        return entities[0].map(userFromDatastore);
    });
}

/* ---- End User Model Functions ---- */

// REMEMBER TO ADD SUB PROPERTY TO BOAT AND LOAD

/* ---- Begin Boat Model Functions ---- */

/**
 * Function: post_boat
 * Parameters: name, type, length, owner
 * Returns: Key of new boat
 * Description:
 *   This function creates a new boat in the datastore. It
 *   creates a new boat entity in the datastore with the
 *   given parameters and an empty list of loads.
 */
function post_boat(name, type, length) {
    // Create a new boat entity
    const key = datastore.key(BOAT);
    const new_boat = {
        "name": name,
        "type": type,
        "length": length,
        "loads": [],
        "owner": owner
    };

    // Save the new boat entity and return the key
    return datastore.save({ "key": key, "data": new_boat })
    .then(() => {
        return key;
    });
}

/**
 * Function: get_boat
 * Parameters: boat_id
 * Returns: Boat object
 * Description:
 *   This function returns the boat with the given ID.
 */
function get_boat(boat_id) {
    // Create a key for the boat
    const key = datastore.key([BOAT, parseInt(boat_id, 10)]);

    // Get the boat from the datastore
    return datastore.get(key)
    .then((entity) => {
        // If the boat exists, return it
        if (entity[0]) {
            return fromDatastore(req, entity[0], 'boats');
        }
        // Otherwise, return null
        return null;
    });
}

/**
 * Function: get_all_boats
 * Parameters: Cursor (optional)
 * Returns: List of boats
 * Description:
 *   This function returns all boats in the datastore,
 *   displaying their IDs, names, types, lengths, loads,
 *   and self links. It should also include a 'count' of
 *   the total number of boats in the datastore. Finally,
 *   this request is paginated, so it should include up to
 *   five boats per page, with a 'next' link if there are
 *   more boats to display. The first boat is either at the
 *   first index of the datastore or at the index specified
 *   by the 'cursor' query parameter.
 */
async function get_all_boats(req) {
    // Limit the query to 5 boats
    const boatsQuery = datastore.createQuery(BOAT).limit(5);

    // Handling pagination with cursor
    if (req.query.cursor) {
        boatsQuery.start(req.query.cursor);
    }

    // Run query to get boats with pagination
    // Await the result
    const boatsResult = await datastore.runQuery(boatsQuery);

    // Boats holds the boats, info holds the pagination info
    const boats = boatsResult[0];
    const info = boatsResult[1];

    // Format the boats with ids and self links
    const formattedBoats = boats.map(boat => fromDatastore(req, boat, 'boats'));

    // Get total count of boats
    const totalBoatsCount = await getTotalBoatCount();

    // Prepare the response
    const response = {
        boats: formattedBoats,
        count: totalBoatsCount
    };

    // Add a 'next' link if there are more boats to display
    if (info.moreResults !== Datastore.NO_MORE_RESULTS) {
        // HTTP for localhost, HTTPS for App Engine
        response.next = `http://${req.get('host')}/boats?cursor=${info.endCursor}`;
    }

    // Return the fully assembled response in format:
    // { boats: [boat1, boat2, ...], count: 5, next: '???' or not included }
    return response;
}

/**
 * Function: get_boats_by_owner
 * Parameters: owner, Cursor (optional)
 * Returns: List of boats
 * Description:
 *   This function returns all boats owned by the user
 *   with the given owner ID. It is very similar to the
 *   get_all_boats function, except it only returns the
 *   boats owned by the user.
 */
async function get_boats_by_owner(owner, req) {
    // Limit the query to 5 boats
    const boatsQuery = datastore.createQuery(BOAT).filter('owner', '=', owner).limit(5);

    // Handling pagination with cursor
    if (req.query.cursor) {
        boatsQuery.start(req.query.cursor);
    }

    // Run query to get boats with pagination
    // Await the result
    // Query needs to be modified to filter by owner (sub property in req.user)
    const boatsResult = await datastore.runQuery(boatsQuery);

    // Boats holds the boats, info holds the pagination info
    const boats = boatsResult[0];
    const info = boatsResult[1];

    // Format the boats with ids and self links
    const formattedBoats = boats.map(boat => fromDatastore(req, boat, 'boats'));

    // Get total count of boats owned by the user
    const totalBoatsCount = await getTotalBoatCountByOwner(owner);

    // Prepare the response
    const response = {
        boats: formattedBoats,
        count: totalBoatsCount
    };

    // Add a 'next' link if there are more boats to display
    if (info.moreResults !== Datastore.NO_MORE_RESULTS) {
        // HTTP for localhost, HTTPS for App Engine
        response.next = `http://${req.get('host')}/boats?cursor=${info.endCursor}`;
    }

    // Return the fully assembled response in format:
    // { boats: [boat1, boat2, ...], count: 5, next: '???' or not included }
    return response;
}

/**
 * Function: put_boat
 * Parameters: boat_id, name, type, length
 * Returns: Boat object
 * Description:
 *   This function replaces the boat with the given ID
 *   with the given parameters. This function is only called
 *   after the request has been validated, so it is assumed
 *   that all parameters are valid.
 */
function put_boat(boat_id, name, type, length) {
    // Create a key for the boat
    const key = datastore.key([BOAT, parseInt(boat_id, 10)]);

    // Get the boat from the datastore
    return datastore.get(key)
    .then((entity) => {
        // If the boat exists, update it
        if (entity[0]) {
            const currentBoat = entity[0];
            currentBoat.name = name;
            currentBoat.type = type;
            currentBoat.length = length;
            return datastore.update({ "key": key, "data": currentBoat })
            .then(() => {
                return key;
            });
        }
        // Otherwise, return null
        return null;
    });
}

/**
 * Function: patch_boat
 * Parameters: boat_id, name, type, length
 * Returns: Boat object
 * Description:
 *   This function updates the boat with the given ID
 *   with the given parameters. This function is only called
 *   after the request has been validated, so it is assumed
 *   that at least one parameter is valid.
 */
function patch_boat(boat_id, name, type, length) {
    // Create a key for the boat
    const key = datastore.key([BOAT, parseInt(boat_id, 10)]);

    // Get the boat from the datastore
    return datastore.get(key)
    .then((entity) => {
        // If the boat exists, update it
        if (entity[0]) {
            const currentBoat = entity[0];
            if (name) {
                currentBoat.name = name;
            }
            if (type) {
                currentBoat.type = type;
            }
            if (length) {
                currentBoat.length = length;
            }
            return datastore.update({ "key": key, "data": currentBoat })
            .then(() => {
                return key;
            });
        }
        // Otherwise, return null
        return null;
    });
}

/**
 * Function: delete_boat
 * Parameters: boat_id
 * Returns: N/A
 * Description:
 *   This function deletes the boat with the given ID.
 *   This function is only called after the request has
 *   been validated, so it is assumed that the boat exists
 *   and has no loads.
 */
function delete_boat(boat_id) {
    // Create a key for the boat
    const key = datastore.key([BOAT, parseInt(boat_id, 10)]);
    return datastore.delete(key);
}

/* ---- End Boat Model Functions ---- */

/* ---- Begin Load Model Functions ---- */

/**
 * Function: post_load
 * Parameters: volume, item, owner
 * Returns: Key of new load
 * Description:
 *   This function creates a new load in the datastore. It
 *   creates a new load entity in the datastore with the
 *   given parameters, an empty carrier, and the current
 *   date.
 */
function post_load(volume, item) {
    // Get the current date, using US format
    // Enforce "MM/DD/YYYY" incase something weird happens with the testing suite
    const CURRENT_DATE = new Date().toLocaleDateString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
    });

    // Create a new load entity
    const key = datastore.key(LOAD);
    const new_load = {
        "volume": volume,
        "carrier": {},
        "item": item,
        "creation_date": CURRENT_DATE,
        "owner": owner
    };

    // Save the new load entity and return the key
    return datastore.save({ "key": key, "data": new_load })
    .then(() => {
        return key;
    });
}

/**
 * Function: get_load
 * Parameters: load_id
 * Returns: Load object
 * Description:
 *   This function returns the load with the given ID.
 *   This function is only called after the request has
 *   been validated, so it is assumed that the load exists.
 *   The load is returned with its ID, volume, carrier,
 *   item, creation date, and self link.
 */
function get_load(load_id) {
    // Create a key for the load
    const key = datastore.key([LOAD, parseInt(load_id, 10)]);

    // Get the load from the datastore
    return datastore.get(key)
    .then((entity) => {
        // If the load exists, return it
        if (entity[0]) {
            return fromDatastore(req, entity[0], 'loads');
        }
        // Otherwise, return null
        return null;
    });
}

/**
 * Function: get_all_loads
 * Parameters: Cursor (optional)
 * Returns: List of loads
 * Description:
 *   This function returns all loads in the datastore,
 *   displaying their IDs, volumes, carriers, items,
 *   creation dates, and self links. It should also
 *   include a 'count' of the total number of loads in
 *   the datastore. Finally, this request is paginated,
 *   so it should include up to five loads per page, with
 *   a 'next' link if there are more loads to display.
 *   The first load is either at the first index of the
 *   datastore or at the index specified by the 'cursor'
 *   query parameter.
 */
async function get_all_loads(req) {
    // Limit the query to 5 loads
    const loadsQuery = datastore.createQuery(LOAD).limit(5);

    // Handling pagination with cursor
    if (req.query.cursor) {
        loadsQuery.start(req.query.cursor);
    }

    // Run query to get loads with pagination
    // Await the result
    const loadsResult = await datastore.runQuery(loadsQuery);

    // Loads holds the loads, info holds the pagination info
    const loads = loadsResult[0];
    const info = loadsResult[1];

    // Format the loads with ids and self links
    const formattedLoads = loads.map(load => fromDatastore(req, load, 'loads'));

    // Get total count of loads
    const totalLoadsCount = await getTotalLoadCount();

    // Prepare the response
    const response = {
        loads: formattedLoads,
        count: totalLoadsCount
    };

    // Add a 'next' link if there are more loads to display
    if (info.moreResults !== Datastore.NO_MORE_RESULTS) {
        // HTTP for localhost, HTTPS for App Engine
        response.next = `http://${req.get('host')}/loads?cursor=${info.endCursor}`;
    }

    // Return the fully assembled response in format:
    // { loads: [load1, load2, ...], count: 5, next: '???' or not included }
    return response;
}

/**
 * Function: get_loads_by_owner
 * Parameters: owner, Cursor (optional)
 * Returns: List of loads
 * Description:
 *   This function returns all loads owned by the user
 *   with the given owner ID. It is very similar to the
 *   get_all_loads function, except it only returns the
 *   loads owned by the user.
 */
async function get_loads_by_owner(owner, req) {
    // Limit the query to 5 loads
    const loadsQuery = datastore.createQuery(LOAD).filter('owner', '=', owner).limit(5);

    // Handling pagination with cursor
    if (req.query.cursor) {
        loadsQuery.start(req.query.cursor);
    }

    // Run query to get loads with pagination
    // Await the result
    // Query needs to be modified to filter by owner (sub property in req.user)
    const loadsResult = await datastore.runQuery(loadsQuery);

    // Loads holds the loads, info holds the pagination info
    const loads = loadsResult[0];
    const info = loadsResult[1];

    // Format the loads with ids and self links
    const formattedLoads = loads.map(load => fromDatastore(req, load, 'loads'));

    // Get total count of loads by the user
    const totalLoadsCount = await getTotalLoadCountByOwner(owner);

    // Prepare the response
    const response = {
        loads: formattedLoads,
        count: totalLoadsCount
    };

    // Add a 'next' link if there are more loads to display
    if (info.moreResults !== Datastore.NO_MORE_RESULTS) {
        // HTTP for localhost, HTTPS for App Engine
        response.next = `http://${req.get('host')}/loads?cursor=${info.endCursor}`;
    }

    // Return the fully assembled response in format:
    // { loads: [load1, load2, ...], count: 5, next: '???' or not included }
    return response;
}

/**
 * Function: put_load
 * Parameters: load_id, volume, item
 * Returns: Load object
 * Description:
 *   This function replaces the load with the given ID
 *   with the given parameters. This function is only called
 *   after the request has been validated, so it is assumed
 *   that all parameters are valid.
 */
function put_load(load_id, volume, item) {
    // Create a key for the load
    const key = datastore.key([LOAD, parseInt(load_id, 10)]);

    // Get the load from the datastore
    return datastore.get(key)
    .then((entity) => {
        // If the load exists, update it
        if (entity[0]) {
            const currentLoad = entity[0];
            currentLoad.volume = volume;
            currentLoad.item = item;
            return datastore.update({ "key": key, "data": currentLoad })
            .then(() => {
                return key;
            });
        }
        // Otherwise, return null
        return null;
    });
}

/**
 * Function: patch_load
 * Parameters: load_id, volume, item
 * Returns: Load object
 * Description:
 *   This function updates the load with the given ID
 *   with the given parameters. This function is only called
 *   after the request has been validated, so it is assumed
 *   that at least one parameter is valid.
 */
function patch_load(load_id, volume, item) {
    // Create a key for the load
    const key = datastore.key([LOAD, parseInt(load_id, 10)]);

    // Get the load from the datastore
    return datastore.get(key)
    .then((entity) => {
        // If the load exists, update it
        if (entity[0]) {
            const currentLoad = entity[0];
            if (volume) {
                currentLoad.volume = volume;
            }
            if (item) {
                currentLoad.item = item;
            }
            return datastore.update({ "key": key, "data": currentLoad })
            .then(() => {
                return key;
            });
        }
        // Otherwise, return null
        return null;
    });
}

/**
 * Function: delete_load
 * Parameters: load_id
 * Returns: N/A
 * Description:
 *   This function deletes the load with the given ID.
 *   This function is only called after the request has
 *   been validated, so it is assumed that the load exists
 *   and has no carrier.
 */
function delete_load(load_id) {
    // Create a key for the load
    const key = datastore.key([LOAD, parseInt(load_id, 10)]);
    return datastore.delete(key);
}

/* ---- End Load Model Functions ---- */

/* ---- Begin Boat/Load Model Functions ---- */

/**
 * Function: append_load_to_boat
 * Parameters: boat_id, load_id
 * Returns: Boat object
 * Description:
 *   This function appends the specified load to the
 *   specified boat's list of loads. The load must not
 *   already be assigned to any boat. This function is
 *   only called after the request has been validated,
 *   so it is assumed that the boat and load exist and
 *   that the load is not already assigned to a boat.
 *   The boat is returned with al of its information,
 *   with the new load appended to its list of loads.
 */
function append_load_to_boat(boat_id, load_id) {
    // Create keys for the boat and load
    const boatKey = datastore.key([BOAT, parseInt(boat_id, 10)]);
    const loadKey = datastore.key([LOAD, parseInt(load_id, 10)]);

    // Get the boat and load from the datastore
    return datastore.get(boatKey)
    .then((boatEntity) => {
        return datastore.get(loadKey)
        .then((loadEntity) => {
            // If the boat and load exist, append the load to the boat
            if (boatEntity[0] && loadEntity[0]) {
                const currentBoat = boatEntity[0];
                const currentLoad = loadEntity[0];
                
                // Add the load to the boat's list of loads
                currentBoat.loads.push(currentLoad);
                return datastore.update({ "key": boatKey, "data": currentBoat })
                .then(() => {
                    return boatKey;
                });
            }
            // Otherwise, return null
            return null;
        });
    });
}

/**
 * Function: remove_load_from_boat
 * Parameters: boat_id, load_id
 * Returns: Boat object
 * Description:
 *   This function removes the specified load from the
 *   specified boat's list of loads. The load must already
 *   be assigned to the boat. This function is only called
 *   after the request has been validated, so it is assumed
 *   that the boat and load exist and that the load is
 *   already assigned to the boat. The boat is returned
 *   with all of its information, with the specified load
 *   removed from its list of loads.
 */
function remove_load_from_boat(boat_id, load_id) {
    // Create keys for the boat and load
    const boatKey = datastore.key([BOAT, parseInt(boat_id, 10)]);
    const loadKey = datastore.key([LOAD, parseInt(load_id, 10)]);

    // Get the boat and load from the datastore
    return datastore.get(boatKey)
    .then((boatEntity) => {
        return datastore.get(loadKey)
        .then((loadEntity) => {
            // If the boat and load exist, remove the load from the boat
            if (boatEntity[0] && loadEntity[0]) {
                const currentBoat = boatEntity[0];
                const currentLoad = loadEntity[0];
                
                // Remove the load from the boat's list of loads
                const index = currentBoat.loads.indexOf(currentLoad);
                currentBoat.loads.splice(index, 1);
                return datastore.update({ "key": boatKey, "data": currentBoat })
                .then(() => {
                    return boatKey;
                });
            }
            // Otherwise, return null
            return null;
        });
    });
}

/* ---- End Boat/Load Model Functions ---- */

/* ---- Begin User Routes ---- */

/**
 * Debug Route: POST /users
 * IMPLEMENTATION TBD
 */

/**
 * Route: GET /users
 * Parameters: None
 * Description:
 *   This route returns all users in the datastore,
 *   displaying their IDs. This is the only collection
 *   that does not need to be paginated.
 * Status Codes:
 *   200 - Users returned successfully.
 */
app.get('/users', (req, res) => {
    // Return all users in the datastore
    get_users()
    .then((users) => {
        return res.status(200).json(users);
    })
    .catch((err) => {
        return res.status(500).json({ Error: err });
    });
});

/* ---- End User Routes ---- */

/* ---- Begin Boat Routes ---- */

/**
 * Route: POST /boats
 * Parameters: name, type, length (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   This route creates a new boat in the datastore with
 *   the given parameters and an empty list of loads. The
 *   request must include a valid JWT in the Authorization
 *   header.
 * Status Codes:
 *   201 - Boat created successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   406 - Client does not accept JSON.
 */
app.post('/boats', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request body is valid
    if (!req.body.name || !req.body.type || !req.body.length) {
        return res.status(400).json({ Error: 'The request object is missing at least one of the required attributes.' });
    }

    // Create a new boat in the datastore
    post_boat(req.body.name, req.body.type, req.body.length, req.user.sub)
    .then((key) => {
        // Get the boat from the datastore
        get_boat(key.id)
        .then((boat) => {
            // Return the boat
            res.status(201).json(boat);
        })
        .catch((err) => {
            // Handle errors in getting the boat
            res.status(500).json({ Error: 'Internal Server Error' });
        });
    })
    .catch((err) => {
        // Handle errors in creating the boat
        res.status(500).json({ Error: 'Internal Server Error' });
    });
});

/**
 * Route: GET /boats/:boat_id
 * Parameters: boat_id (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   This route returns the boat with the given ID. This
 *   route is not protected.
 * Status Codes:
 *   200 - Boat returned successfully.
 *   404 - Boat not found.
 *   406 - Client does not accept JSON.
 */
app.get('/boats/:boat_id', (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Get the boat from the datastore
    get_boat(req.params.boat_id)
    .then((boat) => {
        // If the boat exists, return it
        if (boat) {
            res.status(200).json(boat);
        }
        // Otherwise, return 404
        else {
            res.status(404).json({ Error: 'No boat with this boat_id exists.' });
        }
    })
    .catch((err) => {
        res.status(500).json({ Error: err });
    });
});

/**
 * Route: GET /boats
 * Parameters: N/A
 * Returns: List of boats (via JSON)
 * Description:
 *   This route returns all boats in the datastore.
 *   If a valid JWT is provided, then only the boats
 *   owned by the user are returned. Otherwise, all
 *   boats are returned. The response is paginated
 *   with a maximum of five boats per page.
 * Status Codes:
 *   200 - Boats returned successfully.
 *   406 - Client does not accept JSON.
 */
app.get('/boats', checkJwtOptional, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request has a valid JWT
    if (req.user && req.user.sub) {
        // Get the boats owned by the user
        get_boats_by_owner(req.user.sub, req)
        .then((boats) => {
            res.status(200).json(boats);
        })
        .catch((err) => {
            res.status(500).json({ Error: err });
        });
    }
    // Otherwise, get all boats
    else {
        // Get all boats
        get_all_boats(req)
        .then((boats) => {
            res.status(200).json(boats);
        })
        .catch((err) => {
            res.status(500).json({ Error: err });
        });
    }
});

/**
 * Route: PUT /boats/:boat_id
 * Parameters: boat_id, name, type, length (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   Replace the boat with the given ID with the given
 *   parameters. The request must include all parameters
 *   or it is invalid. The request must also include a
 *   valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Boat replaced successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat not found.
 *   405 - Boat has a load(s) and cannot be replaced.
 *   406 - Client does not accept JSON.
 */
app.put('/boats/:boat_id', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request body is valid
    if (!req.body.name || !req.body.type || !req.body.length) {
        return res.status(400).json({ Error: 'The request object is missing at least one of the required attributes.' });
    }

    // Get the boat from the datastore
    get_boat(req.params.boat_id)
    .then((boat) => {
        // If the boat exists, check the JWT and loads
        if (boat) {
            // If the sub property of the JWT does not match the owner of the boat, return 403
            if (req.user.sub !== boat.owner) {
                return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the boat.' });
            }

            // If the boat has loads, return 405
            if (boat.loads && boat.loads.length > 0) {
                return res.status(405).json({ Error: 'The boat has load(s) and cannot be replaced.' });
            }

            // Replace the boat
            put_boat(req.params.boat_id, req.body.name, req.body.type, req.body.length)
            .then(() => get_boat(req.params.boat_id))
            .then((updatedBoat) => res.status(200).json(updatedBoat))
            .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
        } else {
            // If the boat does not exist, return 404
            return res.status(404).json({ Error: 'No boat with this boat_id exists.' });
        }
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/**
 * Route: PATCH /boats/:boat_id
 * Parameters: boat_id, name, type, length (via JSON)
 * Returns: Boat object (via JSON)
 * Description:
 *   Update the boat with the given ID with the given
 *   parameters. The request must include at least one
 *   parameter or it is invalid. The request must also
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Boat updated successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat not found.
 *   405 - Boat has a load(s) and cannot be updated.
 *   406 - Client does not accept JSON.
 */
app.patch('/boats/:boat_id', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request body is valid
    if (!req.body.name && !req.body.type && !req.body.length) {
        return res.status(400).json({ Error: 'The request object is missing at least one of the required attributes.' });
    }

    // Get the boat from the datastore
    get_boat(req.params.boat_id)
    .then((boat) => {
        // If the boat exists, check the JWT and loads
        if (boat) {
            // If the sub property of the JWT does not match the owner of the boat, return 403
            if (req.user.sub !== boat.owner) {
                return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the boat.' });
            }

            // If the boat has loads, return 405
            if (boat.loads && boat.loads.length > 0) {
                return res.status(405).json({ Error: 'The boat has load(s) and cannot be updated.' });
            }

            // Update the boat
            patch_boat(req.params.boat_id, req.body.name, req.body.type, req.body.length)
            .then(() => get_boat(req.params.boat_id))
            .then((updatedBoat) => res.status(200).json(updatedBoat))
            .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
        } else {
            // If the boat does not exist, return 404
            return res.status(404).json({ Error: 'No boat with this boat_id exists.' });
        }
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/**
 * Route: DELETE /boats/:boat_id
 * Parameters: boat_id (via JSON)
 * Returns: N/A
 * Description:
 *   Delete the boat with the given ID. The request must
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   204 - Boat deleted successfully.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat not found.
 *   405 - Boat has a load(s) and cannot be deleted.
 */
app.delete('/boats/:boat_id', checkJwt, (req, res) => {
    // Get the boat from the datastore
    get_boat(req.params.boat_id)
    .then((boat) => {
        // If the boat exists, check the JWT and loads
        if (boat) {
            // If the sub property of the JWT does not match the owner of the boat, return 403
            if (req.user.sub !== boat.owner) {
                return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the boat.' });
            }

            // If the boat has loads, return 405
            if (boat.loads && boat.loads.length > 0) {
                return res.status(405).json({ Error: 'The boat has load(s) and cannot be deleted.' });
            }

            // Delete the boat
            delete_boat(req.params.boat_id)
            .then(() => res.status(204).end())
            .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
        } else {
            // If the boat does not exist, return 404
            return res.status(404).json({ Error: 'No boat with this boat_id exists.' });
        }
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/* ---- End Boat Routes ---- */

/* ---- Begin Load Routes ---- */

/**
 * Route: POST /loads
 * Parameters: volume, item (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *   This route creates a new load in the datastore with
 *   the given parameters, an empty carrier, and the
 *   current date. The request must include a valid JWT
 *   in the Authorization header.
 * Status Codes:
 *   201 - Load created successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   406 - Client does not accept JSON.
 */
app.post('/loads', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request body is valid
    if (!req.body.volume || !req.body.item) {
        return res.status(400).json({ Error: 'The request object is missing at least one of the required attributes.' });
    }

    // Create a new load in the datastore
    post_load(req.body.volume, req.body.item, req.user.sub)
    .then((key) => {
        // Get the load from the datastore
        get_load(key.id)
        .then((load) => {
            // Return the load
            res.status(201).json(load);
        })
        .catch((err) => {
            // Handle errors in getting the load
            res.status(500).json({ Error: 'Internal Server Error' });
        });
    })
    .catch((err) => {
        // Handle errors in creating the load
        res.status(500).json({ Error: 'Internal Server Error' });
    });
});

/**
 * Route: GET /loads/:load_id
 * Parameters: load_id (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *  This route returns the load with the given ID. This
 *  route is not protected.
 * Status Codes:
 *   200 - Load returned successfully.
 *   404 - Load not found.
 *   406 - Client does not accept JSON.
 */
app.get('/loads/:load_id', (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Get the load from the datastore
    get_load(req.params.load_id)
    .then((load) => {
        // If the load exists, return it
        if (load) {
            res.status(200).json(load);
        }
        // Otherwise, return 404
        else {
            res.status(404).json({ Error: 'No load with this load_id exists.' });
        }
    })
    .catch((err) => {
        res.status(500).json({ Error: err });
    });
});

/**
 * Route: GET /loads
 * Parameters: N/A
 * Returns: List of loads (via JSON)
 * Description:
 *   This route returns all loads in the datastore.
 *   If a valid JWT is provided, then only the loads
 *   carried by the user's boats are returned. Otherwise,
 *   all loads are returned. The response is paginated
 *   with a maximum of five loads per page.
 * Status Codes:
 *   200 - Loads returned successfully.
 *   406 - Client does not accept JSON.
 */
app.get('/loads', checkJwtOptional, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request has a valid JWT
    if (req.user && req.user.sub) {
        // Get the loads owned by the user
        get_loads_by_owner(req.user.sub, req)
        .then((loads) => {
            res.status(200).json(loads);
        })
        .catch((err) => {
            res.status(500).json({ Error: err });
        });
    }
    // Otherwise, get all loads
    else {
        // Get all loads
        get_all_loads(req)
        .then((loads) => {
            res.status(200).json(loads);
        })
        .catch((err) => {
            res.status(500).json({ Error: err });
        });
    }
});

/**
 * Route: PUT /loads/:load_id
 * Parameters: load_id, volume, item (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *   Replace the load with the given ID with the given
 *   parameters. The request must include all parameters
 *   or it is invalid. The request must also include a
 *   valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Load replaced successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Load not found.
 *   405 - Load is assigned to a boat and cannot be replaced.
 *   406 - Client does not accept JSON.
 */
app.put('/loads/:load_id', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request body is valid
    if (!req.body.volume || !req.body.item) {
        return res.status(400).json({ Error: 'The request object is missing at least one of the required attributes.' });
    }

    // Get the load from the datastore
    get_load(req.params.load_id)
    .then((load) => {
        // If the load exists, check the JWT and if it has a carrier
        if (load) {
            // If the sub property of the JWT does not match the owner of the load, return 403
            if (req.user.sub !== load.owner) {
                return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the load.' });
            }

            // If the load has a carrier, return 405
            if (load.carrier && load.carrier.id) {
                return res.status(405).json({ Error: 'The load has a carrier and cannot be replaced.' });
            }

            // Replace the load
            put_load(req.params.load_id, req.body.volume, req.body.item)
            .then(() => get_load(req.params.load_id))
            .then((updatedLoad) => res.status(200).json(updatedLoad))
            .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
        } else {
            // If the load does not exist, return 404
            return res.status(404).json({ Error: 'No load with this load_id exists.' });
        }
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/**
 * Route: PATCH /loads/:load_id
 * Parameters: load_id, volume, item (via JSON)
 * Returns: Load object (via JSON)
 * Description:
 *   Update the load with the given ID with the given
 *   parameters. The request must include at least one
 *   parameter or it is invalid. The request must also
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Load updated successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Load not found.
 *   405 - Load is assigned to a boat and cannot be updated.
 *   406 - Client does not accept JSON.
 */
app.patch('/loads/:load_id', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }

    // Check if the request body is valid
    if (!req.body.volume && !req.body.item) {
        return res.status(400).json({ Error: 'The request object is missing at least one of the required attributes.' });
    }

    // Get the load from the datastore
    get_load(req.params.load_id)
    .then((load) => {
        // If the load exists, check the JWT and if it has a carrier
        if (load) {
            // If the sub property of the JWT does not match the owner of the load, return 403
            if (req.user.sub !== load.owner) {
                return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the load.' });
            }

            // If the load has a carrier, return 405
            if (load.carrier && load.carrier.id) {
                return res.status(405).json({ Error: 'The load has a carrier and cannot be updated.' });
            }

            // Update the load
            patch_load(req.params.load_id, req.body.volume, req.body.item)
            .then(() => get_load(req.params.load_id))
            .then((updatedLoad) => res.status(200).json(updatedLoad))
            .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
        } else {
            // If the load does not exist, return 404
            return res.status(404).json({ Error: 'No load with this load_id exists.' });
        }
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/**
 * Route: DELETE /loads/:load_id
 * Parameters: load_id (via JSON)
 * Returns: N/A
 * Description:
 *   Delete the load with the given ID. The request must
 *   include a valid JWT in the Authorization header.
 * Status Codes:
 *   204 - Load deleted successfully.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Load not found.
 *   405 - Load is assigned to a boat and cannot be deleted.
 */
app.delete('/loads/:load_id', checkJwt, (req, res) => {
    // Get the load from the datastore
    get_load(req.params.load_id)
    .then((load) => {
        // If the load exists, check the JWT and carrier
        if (load) {
            // If the sub property of the JWT does not match the owner of the load, return 403
            if (req.user.sub !== load.owner) {
                return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the load.' });
            }

            // If the load has a carrier, return 405
            if (load.carrier && load.carrier.id) {
                return res.status(405).json({ Error: 'The load has a carrier and cannot be deleted.' });
            }

            // Delete the load
            delete_load(req.params.load_id)
            .then(() => res.status(204).end())
            .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
        } else {
            // If the load does not exist, return 404
            return res.status(404).json({ Error: 'No load with this load_id exists.' });
        }
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/* ---- End Load Routes ---- */

/* ---- Begin Boat/Load Routes ---- */

/**
 * Route: PATCH /boats/:boat_id/loads/:load_id
 * Parameters: boat_id, load_id (via JSON)
 * Returns: Updated Boat object with appended Load information (via JSON)
 * Description:
 *   This route appends the specified load to the specified boat's
 *   list of loads.  The load must not already be assigned to any
 *   boat.  The request must include a valid JWT in the Authorization
 *   header.
 * Status Codes:
 *   200 - Load appended to boat successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat or Load not found.
 *   405 - Load is already assigned to a boat.
 *   406 - Client does not accept JSON.
 */
app.patch('/boats/:boat_id/loads/:load_id', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }
    
    // Get the boat and load from the datastore
    get_boat(req.params.boat_id)
    .then((boat) => {
        get_load(req.params.load_id)
        .then((load) => {
            // If the boat and load exist, check the JWT and if the load has a carrier
            if (boat && load) {
                // If the sub property of the JWT does not match the owner of the boat, return 403
                if (req.user.sub !== boat.owner) {
                    return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the boat.' });
                }

                // If the sub property of the JWT does not match the owner of the load, return 403
                if (req.user.sub !== load.owner) {
                    return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the load.' });
                }

                // Check if the load already has a carrier
                if (load.carrier && load.carrier.id) {
                    return res.status(405).json({ Error: 'The load is already assigned to a boat.' });
                }

                // Append the load to the boat
                append_load_to_boat(req.params.boat_id, req.params.load_id)
                .then(() => get_boat(req.params.boat_id))
                .then((updatedBoat) => res.status(200).json(updatedBoat))
                .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
            } else {
                // If the boat or load does not exist, return 404
                return res.status(404).json({ Error: 'No boat or load with this ID exists.' });
            }
        })
        .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/**
 * Route: DELETE /boats/:boat_id/loads/:load_id
 * Parameters: boat_id, load_id (via JSON)
 * Returns: Updated Boat object with removed Load information (via JSON)
 * Description:
 *   This route removes the specified load from the specified boat's
 *   list of loads.  The load must already be assigned to the boat.
 *   The request must include a valid JWT in the Authorization header.
 * Status Codes:
 *   200 - Load removed from boat successfully.
 *   400 - Invalid request body.
 *   401 - No JWT provided.
 *   403 - Invalid JWT provided.
 *   404 - Boat or Load not found.
 *   405 - Load is not assigned to the boat.
 *   406 - Client does not accept JSON.
 */
app.delete('/boats/:boat_id/loads/:load_id', checkJwt, (req, res) => {
    // Check if the request does not accept JSON
    if (!req.accepts('application/json')) {
        return res.status(406).send('Server only accepts application/json data.');
    }
    
    // Get the boat and load from the datastore
    get_boat(req.params.boat_id)
    .then((boat) => {
        get_load(req.params.load_id)
        .then((load) => {
            // If the boat and load exist, check the JWT and if the load carrier matches the boat
            if (boat && load) {
                // If the sub property of the JWT does not match the owner of the boat, return 403
                if (req.user.sub !== boat.owner) {
                    return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the boat.' });
                }

                // If the sub property of the JWT does not match the owner of the load, return 403
                if (req.user.sub !== load.owner) {
                    return res.status(403).json({ Error: 'The sub property of the JWT does not match the owner of the load.' });
                }

                // Check if the load has no boat
                if (!load.carrier.id) {
                    return res.status(405).json({ Error: 'The load is not assigned to any boat.' });
                }

                // Check if the load is assigned to a different boat
                if (load.carrier.id !== boat.id) {
                    return res.status(405).json({ Error: 'The load is not assigned to this boat.' });
                }

                // Remove the load from the boat
                remove_load_from_boat(req.params.boat_id, req.params.load_id)
                .then(() => get_boat(req.params.boat_id))
                .then((updatedBoat) => res.status(200).json(updatedBoat))
                .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
            } else {
                // If the boat or load does not exist, return 404
                return res.status(404).json({ Error: 'No boat or load with this ID exists.' });
            }
        })
        .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
    })
    .catch((err) => res.status(500).json({ Error: 'Internal Server Error' }));
});

/* ---- End Boat/Load Routes ---- */

// Listen to the App Engine-specified port, or 8080 otherwise
const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
    console.log(`Server listening on port ${PORT}...`);
});
